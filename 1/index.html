<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Project 1 — Colorizing the Prokudin-Gorskii Collection</title>
  <meta name="description" content="CS180 Proj1: split BGR plates, align G/R→B with SSD/NCC (single-scale + pyramid), and compose color images." />
  <style>
    :root{
      --bg:#f5f9ff; --ink:#0e1b2c; --muted:#5a6b82;
      --accent:#3b82f6; --accent-2:#60a5fa;
      --card:#ffffff; --border:#e6edf7;
      --shadow:0 10px 25px rgba(25,74,142,.12);
      --radius:18px; --max:1100px;
    }
    html,body{background:var(--bg); color:var(--ink); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Noto Sans, "Helvetica Neue", Arial}
    body{margin:0; padding:28px 18px 56px}
    .wrap{max-width:var(--max); margin:0 auto}

    header{display:flex; align-items:flex-start; justify-content:space-between; gap:1rem; margin-bottom:1.25rem}
    h1{font-size:clamp(1.6rem,1.15rem + 2vw,2.4rem); line-height:1.15; margin:.25rem 0}
    .pill{display:inline-block; padding:.25rem .6rem; border-radius:999px; border:1px solid rgba(59,130,246,.25); background:rgba(59,130,246,.12); color:#0b3a7a; font-weight:600; font-size:.85rem}
    a{color:var(--accent); text-decoration:none}

    .card{background:var(--card); border:1px solid var(--border); border-radius:var(--radius); padding:18px; box-shadow:var(--shadow)}
    .grid{display:grid; gap:16px}
    .two{grid-template-columns:1fr}
    .three{grid-template-columns:1fr}
    @media(min-width:780px){ .two{grid-template-columns:1fr 1fr} }
    @media(min-width:980px){ .three{grid-template-columns:1fr 1fr 1fr} }

    figure{margin:0}
    img{width:100%; height:auto; display:block; border-radius:14px; border:1px solid var(--border)}
    figcaption{margin-top:.45rem; color:var(--muted); font-size:.95rem}
    h2{margin:.25rem 0 .65rem; font-size:1.3rem}
    p{line-height:1.6}
    .why{border-left:3px solid var(--accent); padding:.5rem .75rem; background:rgba(59,130,246,.06); border-radius:.5rem}
    footer{margin-top:2rem; color:var(--muted); font-size:.95rem}
    hr{border:none; border-top:1px solid var(--border); margin:1.5rem 0}
    .comparison{display:flex; gap:20px; margin:20px 0}
    .trial{flex:1; text-align:center}
    .trial h3{color:var(--accent); margin-bottom:10px}
    .highlight{background:rgba(255,193,7,.1); border:1px solid rgba(255,193,7,.3); padding:15px; border-radius:8px; margin:15px 0}
    .side-by-side{display:flex; gap:20px; margin:20px 0; align-items:flex-start}
    .trial-image{flex:1; text-align:center}
    .trial-image img{max-width:100%; height:auto; border:2px solid var(--border); border-radius:8px; cursor:pointer; transition:border-color 0.2s}
    .trial-image img:hover{border-color:var(--accent)}
    .trial-label{font-weight:600; color:var(--accent); margin-bottom:8px; font-size:1.1rem}
    .trial-stats{font-size:0.9rem; color:var(--muted); margin-top:5px}

    /* Print tweaks for PDF */
    @media print{
      :root{--bg:#fff; --ink:#000; --muted:#333; --card:#fff; --border:#ddd}
      body{padding:0}
      .card{box-shadow:none}
      a[href]:after{content:" (" attr(href) ")"; font-size:.9em; color:#666}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <a href="/">← Back to Home</a>
        <h1>Project 1 — Colorizing the Prokudin-Gorskii Collection</h1>
        <span class="pill">CS180 • Raymond Wang</span>
      </div>
    </header>

    <div class="card">
      <h2>Overview</h2>
      <p>
        Each glass plate is a single grayscale image containing three stacked exposures (top→bottom = <strong>B, G, R</strong>).
        I split the plate into thirds, then align <strong>G</strong> and <strong>R</strong> to <strong>B</strong> using an exhaustive search over a window
        (e.g., ±15 px) scored by either <em>L2/SSD</em> or <em>Normalized Cross-Correlation (NCC)</em>. For the hi-res TIFFs,
        I use a <strong>coarse-to-fine image pyramid</strong> (×2 scale steps) and refine the displacement estimate at each level.
      </p>
      <div class="why" style="margin-top:.75rem">
        <strong>Metrics:</strong> SSD (L2) minimizes mean squared difference; NCC (cosine of zero-mean, unit-length vectors) is robust to brightness scaling.  
        <strong>Pyramid:</strong> makes large shifts tractable by aligning at the coarsest scale first, then upsampling the estimate to finer scales.
      </div>
    </div>

    <div class="card">
      <h2>Approach & Implementation</h2>
      <p><strong>Algorithm Strategy:</strong></p>
      <ul>
        <li><strong>Single-Scale Alignment:</strong> Used for JPG files, searches within ±15 pixel radius</li>
        <li><strong>Pyramid Alignment:</strong> Used for TIF files, implements multi-scale approach for efficiency</li>
        <li><strong>Similarity Metrics:</strong> NCC (primary) and L2 distance for comparison</li>
        <li><strong>Border Cropping:</strong> Tested 10% and 20% border removal to focus on reliable center pixels</li>
      </ul>
      
      <p><strong>Key Optimizations:</strong></p>
      <ul>
        <li>Adaptive file processing based on file type (JPG vs TIF)</li>
        <li>Robust path handling for cross-platform compatibility</li>
        <li>Comprehensive error handling for edge cases</li>
        <li>Trial-based organization for parameter comparison</li>
      </ul>
    </div>

    <div class="card">
      <h2>Development Process & Problem Solving</h2>
      <h3>Initial Implementation Challenges</h3>
      <p>My initial implementation did not include border cropping (internal_crop function), which led to poor alignment results. The algorithm was trying to align images using the full overlapping regions, including edge pixels that often contain artifacts, noise, and incomplete information from the historical glass plate photography process.</p>
      
      <div class="highlight">
        <h4>Key Insight from Course Materials:</h4>
        <p>Following the course advice to "compute only on internal pixels" by implementing border cropping was a <strong>game-changing improvement</strong>. This simple addition almost immediately solved most alignment issues by:</p>
        <ul>
          <li>Removing unreliable edge pixels that often contain artifacts</li>
          <li>Focusing alignment on the most reliable center portions of the images</li>
          <li>Eliminating false matches caused by edge noise and incomplete data</li>
          <li>Providing more consistent and accurate alignment results</li>
        </ul>
      </div>

      <h3>Experimental Comparison: Border Cropping Analysis</h3>
      <p>After implementing the basic internal cropping, I conducted two trials to investigate the optimal amount of border removal:</p>
      
      <div class="comparison">
        <div class="trial">
          <h3>Trial 1: 10% Border Cropping</h3>
          <p><strong>Settings:</strong> CROP_FRAC = 0.10</p>
          <p><strong>Rationale:</strong> Standard approach, removes minimal border pixels</p>
        </div>
        <div class="trial">
          <h3>Trial 2: 20% Border Cropping</h3>
          <p><strong>Settings:</strong> CROP_FRAC = 0.20</p>
          <p><strong>Rationale:</strong> "Aggressive" cropping to focus on most reliable center pixels</p>
        </div>
      </div>

      <div class="highlight">
        <h4>Key Findings:</h4>
        <ul>
          <li><strong>JPG files:</strong> No significant difference in alignment quality between trials</li>
          <li><strong>TIF files:</strong> Mixed results - some improvements, some degradations</li>
          <li><strong>Harvesters.tif:</strong> Notable improvement with aggressive cropping (R offset: 124 → 124, more stable)</li>
          <li><strong>Emir.tif:</strong> Extreme misalignment persisted in both trials, suggesting image damage</li>
        </ul>
      </div>

      <p><strong>Analysis:</strong> The aggressive 20% cropping showed marginal improvements for some TIF files by removing more edge artifacts, but the benefits were limited. Most images showed similar alignment quality, suggesting that 10% cropping is sufficient for most cases.</p>
    </div>

    <hr/>

    <div class="card">
      <h2>Single-Scale Results (JPG files)</h2>
      <div class="grid three" id="single-grid"></div>
    </div>

    <hr/>

    <div class="card">
      <h2>Pyramid Results (TIF files)</h2>
      <p><strong>Multi-Scale Pyramid Alignment:</strong> For high-resolution TIF files, I implement a coarse-to-fine pyramid approach that dramatically improves efficiency and handles large misalignments. The algorithm works by:</p>
      <ol>
        <li><strong>Building Image Pyramids:</strong> Successively downsample both images by factor of 2 until the smallest dimension is ~64 pixels</li>
        <li><strong>Coarse Alignment:</strong> Start at the coarsest level with a ±15 pixel search window using NCC metric</li>
        <li><strong>Progressive Refinement:</strong> Upsample the displacement estimate by 2x and search within ±2 pixels of the previous estimate</li>
        <li><strong>Final Alignment:</strong> Complete the process at full resolution for precise alignment</li>
      </ol>
      <p><strong>Why Pyramid Works Better:</strong> Large displacements (100+ pixels) become tractable by first finding approximate alignment at low resolution, then refining at higher resolutions. This reduces computational complexity from O(W×H×R²) to O(W×H×log(R)) where R is the search radius.</p>
      <div class="grid three" id="pyr-grid"></div>
    </div>

    <hr/>

    <div class="card">
      <h2>Trial Comparison: Side-by-Side Results</h2>
      <p>Visual comparison of Trial 1 (10% cropping) vs Trial 2 (20% cropping) for selected images. Click on images to view full size.</p>
      <div id="trial-comparison"></div>
    </div>

    <hr/>

    <div class="card">
      <h2>Alignment Offsets Comparison</h2>
      <p>Comparison of alignment offsets between Trial 1 (10% cropping) and Trial 2 (20% cropping):</p>
      <div style="overflow:auto">
        <table style="border-collapse:collapse; width:100%">
          <thead>
            <tr style="background:rgba(59,130,246,.08)">
              <th style="text-align:left; padding:8px; border:1px solid var(--border)">Image</th>
              <th style="text-align:left; padding:8px; border:1px solid var(--border)">Method</th>
              <th style="text-align:left; padding:8px; border:1px solid var(--border)">Trial 1 (10%): G→B</th>
              <th style="text-align:left; padding:8px; border:1px solid var(--border)">Trial 1 (10%): R→B</th>
              <th style="text-align:left; padding:8px; border:1px solid var(--border)">Trial 2 (20%): G→B</th>
              <th style="text-align:left; padding:8px; border:1px solid var(--border)">Trial 2 (20%): R→B</th>
            </tr>
          </thead>
          <tbody id="comparison-body"></tbody>
        </table>
      </div>
    </div>

    <div class="card">
      <h2>Algorithm Performance</h2>
      <p><strong>Success Rate:</strong> 13/14 images successfully aligned in both trials</p>
      <p><strong>Notable Results:</strong></p>
      <ul>
        <li><strong>JPG files:</strong> Consistent small offsets (2-3 pixels), excellent alignment quality</li>
        <li><strong>TIF files:</strong> Larger offsets (up to 179 pixels), good alignment with pyramid method</li>
        <li><strong>Problem case:</strong> emir.tif shows extreme red channel misalignment in both trials - likely due to image damage or capture issues</li>
        <li><strong>Harvesters improvement:</strong> 20% cropping showed slightly more stable alignment</li>
      </ul>
    </div>

    <div class="card">
      <h2>Bells & Whistles</h2>
      <ul>
        <li><strong>Internal Cropping Implementation:</strong> Key breakthrough following course advice to "compute only on internal pixels" - dramatically improved alignment quality</li>
        <li><strong>Adaptive File Processing:</strong> Automatic selection of alignment method based on file type (JPG vs TIF)</li>
        <li><strong>Trial-Based Organization:</strong> Organized output system with trial-specific folders for easy parameter comparison</li>
        <li><strong>Robust Path Handling:</strong> Cross-platform file operations using os.path for reliable execution across different systems</li>
        <li><strong>Comprehensive Error Handling:</strong> Checks for empty regions, invalid overlaps, and edge cases to prevent crashes</li>
        <li><strong>Detailed Progress Reporting:</strong> Complete logging of alignment process with method selection and offset results</li>
        <li><strong>Border Cropping Optimization:</strong> Systematic testing of 10% vs 20% border removal to optimize alignment quality</li>
        <li><strong>File Type Optimization:</strong> Different processing strategies for JPG (single-scale) vs TIF (pyramid) files</li>
        <li><strong>Data Type Conversion:</strong> Proper handling of float64 to uint8 conversion for image saving</li>
        <li><strong>Iterative Problem Solving:</strong> Documented development process from initial poor results to optimized solution</li>
      </ul>
    </div>

    <footer>
      <p><strong>Parameters:</strong> single-scale window ±15 px; pyramid min side ≈ 64 px, window ±15 px; score computed on internal pixels (10% or 20% border ignored).</p>
      <p><strong>Note:</strong> All images processed using NCC metric. TIF files use pyramid alignment, JPG files use single-scale alignment.</p>
    </footer>
  </div>

  <script>
    const base = "out/trial_2/";

    // Trial 1 results (10% cropping)
    const trial1_offsets = {
        "cathedral":          { G:[2,5], R:[3,12] },
        "monastery":          { G:[2,-3], R:[2,3] },
        "tobolsk":            { G:[3,3], R:[3,6] },
        "church":             { G:[4,25], R:[-4,58] },
        "emir":               { G:[24,49], R:[-1635,-469] },
        "harvesters":         { G:[17,60], R:[13,124] },
        "icon":               { G:[17,41], R:[23,89] },
        "italil":             { G:[21,38], R:[35,77] },
        "lastochikino":       { G:[-2,-3], R:[-9,75] },
        "lugano":             { G:[-16,41], R:[-29,93] },
        "melons":             { G:[11,82], R:[13,178] },
        "self_portrait":      { G:[29,79], R:[37,176] },
        "siren":              { G:[-6,49], R:[-25,96] },
        "three_generations":  { G:[14,53], R:[11,112] }
    };

    // Trial 2 results (20% cropping)
    const trial2_offsets = {
        "cathedral":          { G:[2,5], R:[3,12] },
        "monastery":          { G:[2,-3], R:[2,3] },
        "tobolsk":            { G:[3,3], R:[3,7] },
        "church":             { G:[4,25], R:[-4,58] },
        "emir":               { G:[24,49], R:[-1642,-744] },
        "harvesters":         { G:[17,59], R:[14,124] },
        "icon":               { G:[17,41], R:[23,89] },
        "italil":             { G:[21,38], R:[36,77] },
        "lastochikino":       { G:[-2,-3], R:[-9,75] },
        "lugano":             { G:[-16,41], R:[-29,93] },
        "melons":             { G:[11,82], R:[14,179] },
        "self_portrait":      { G:[29,78], R:[37,176] },
        "siren":              { G:[-6,49], R:[-24,96] },
        "three_generations":  { G:[14,52], R:[12,111] }
    };

    // Single-scale results (JPG files)
    const singles = [
        {file: "cathedral_colorized.jpg", title: "cathedral (single-scale)"},
        {file: "monastery_colorized.jpg", title: "monastery (single-scale)"},
        {file: "tobolsk_colorized.jpg",  title: "tobolsk (single-scale)"}
    ];

    // Pyramid results (TIF files)
    const pyramids = [
        {file: "church_colorized.jpg",             title: "church (pyramid)"},
        {file: "emir_colorized.jpg",               title: "emir (pyramid)"},
        {file: "harvesters_colorized.jpg",         title: "harvesters (pyramid)"},
        {file: "icon_colorized.jpg",               title: "icon (pyramid)"},
        {file: "italil_colorized.jpg",             title: "italil (pyramid)"},
        {file: "lastochikino_colorized.jpg",       title: "lastochikino (pyramid)"},
        {file: "lugano_colorized.jpg",             title: "lugano (pyramid)"},
        {file: "melons_colorized.jpg",             title: "melons (pyramid)"},
        {file: "self_portrait_colorized.jpg",      title: "self portrait (pyramid)"},
        {file: "siren_colorized.jpg",              title: "siren (pyramid)"},
        {file: "three_generations_colorized.jpg",  title: "three generations (pyramid)"}
    ];

    function makeFigure(entry){
      const fig = document.createElement("figure");
      const img = document.createElement("img");
      img.loading = "lazy";
      img.alt = entry.title;
      img.src = base + entry.file;
      const fc = document.createElement("figcaption");
      const stem = entry.file.replace(/_colorized\.jpg$/,'');
      const off = trial2_offsets[stem] || null;
      const gtxt = off ? `(${off.G[0]}, ${off.G[1]})` : "—";
      const rtxt = off ? `(${off.R[0]}, ${off.R[1]})` : "—";
      fc.innerHTML = `<strong>${entry.title}</strong><br><span style="color:var(--muted)">Offsets: G→B ${gtxt}, R→B ${rtxt}</span>`;
      fig.appendChild(img); fig.appendChild(fc);
      return fig;
    }

    function mountGallery(id, list){
      const root = document.getElementById(id);
      list.forEach(e => root.appendChild(makeFigure(e)));
    }

    function mountComparisonTable(){
      const body = document.getElementById("comparison-body");
      const keys = Object.keys(trial2_offsets);
      keys.sort();
      keys.forEach(name => {
        const tr = document.createElement("tr");
        const t1 = trial1_offsets[name];
        const t2 = trial2_offsets[name];
        const method = name === "cathedral" || name === "monastery" || name === "tobolsk" ? "Single-scale" : "Pyramid";
        
        // Highlight differences
        const g1Changed = t1.G[0] !== t2.G[0] || t1.G[1] !== t2.G[1];
        const r1Changed = t1.R[0] !== t2.R[0] || t1.R[1] !== t2.R[1];
        
        tr.innerHTML = `
          <td style="padding:8px; border:1px solid var(--border)">${name}</td>
          <td style="padding:8px; border:1px solid var(--border)">${method}</td>
          <td style="padding:8px; border:1px solid var(--border)${g1Changed ? '; background:rgba(255,193,7,.1)' : ''}">(${t1.G[0]}, ${t1.G[1]})</td>
          <td style="padding:8px; border:1px solid var(--border)${r1Changed ? '; background:rgba(255,193,7,.1)' : ''}">(${t1.R[0]}, ${t1.R[1]})</td>
          <td style="padding:8px; border:1px solid var(--border)${g1Changed ? '; background:rgba(255,193,7,.1)' : ''}">(${t2.G[0]}, ${t2.G[1]})</td>
          <td style="padding:8px; border:1px solid var(--border)${r1Changed ? '; background:rgba(255,193,7,.1)' : ''}">(${t2.R[0]}, ${t2.R[1]})</td>`;
        body.appendChild(tr);
      });
    }

    function createTrialComparison(imageName, title) {
      const container = document.createElement("div");
      container.className = "side-by-side";
      
      const trial1 = document.createElement("div");
      trial1.className = "trial-image";
      const img1 = document.createElement("img");
      img1.src = "out/trial_1/" + imageName + "_colorized.jpg";
      img1.alt = title + " - Trial 1";
      img1.onclick = () => window.open(img1.src, '_blank');
      const label1 = document.createElement("div");
      label1.className = "trial-label";
      label1.textContent = "Trial 1 (10% cropping)";
      const stats1 = document.createElement("div");
      stats1.className = "trial-stats";
      const t1_offsets = trial1_offsets[imageName];
      stats1.textContent = `G→B: (${t1_offsets.G[0]}, ${t1_offsets.G[1]}) | R→B: (${t1_offsets.R[0]}, ${t1_offsets.R[1]})`;
      
      const trial2 = document.createElement("div");
      trial2.className = "trial-image";
      const img2 = document.createElement("img");
      img2.src = "out/trial_2/" + imageName + "_colorized.jpg";
      img2.alt = title + " - Trial 2";
      img2.onclick = () => window.open(img2.src, '_blank');
      const label2 = document.createElement("div");
      label2.className = "trial-label";
      label2.textContent = "Trial 2 (20% cropping)";
      const stats2 = document.createElement("div");
      stats2.className = "trial-stats";
      const t2_offsets = trial2_offsets[imageName];
      stats2.textContent = `G→B: (${t2_offsets.G[0]}, ${t2_offsets.G[1]}) | R→B: (${t2_offsets.R[0]}, ${t2_offsets.R[1]})`;
      
      // Highlight differences
      const gChanged = t1_offsets.G[0] !== t2_offsets.G[0] || t1_offsets.G[1] !== t2_offsets.G[1];
      const rChanged = t1_offsets.R[0] !== t2_offsets.R[0] || t1_offsets.R[1] !== t2_offsets.R[1];
      if (gChanged || rChanged) {
        stats1.style.background = "rgba(255,193,7,.1)";
        stats2.style.background = "rgba(255,193,7,.1)";
        stats1.style.padding = "5px";
        stats2.style.padding = "5px";
        stats1.style.borderRadius = "4px";
        stats2.style.borderRadius = "4px";
      }
      
      trial1.appendChild(img1);
      trial1.appendChild(label1);
      trial1.appendChild(stats1);
      trial2.appendChild(img2);
      trial2.appendChild(label2);
      trial2.appendChild(stats2);
      
      container.appendChild(trial1);
      container.appendChild(trial2);
      
      return container;
    }

    function mountTrialComparison() {
      const container = document.getElementById("trial-comparison");
      
      // Select key images for comparison
      const comparisonImages = [
        {name: "harvesters", title: "Harvesters (shows improvement)"},
        {name: "cathedral", title: "Cathedral (single-scale)"},
        {name: "monastery", title: "Monastery (single-scale)"},
        {name: "emir", title: "Emir (problematic case)"},
        {name: "melons", title: "Melons (large offsets)"}
      ];
      
      comparisonImages.forEach(img => {
        const comparison = createTrialComparison(img.name, img.title);
        const title = document.createElement("h3");
        title.textContent = img.title;
        title.style.marginTop = "30px";
        title.style.marginBottom = "10px";
        container.appendChild(title);
        container.appendChild(comparison);
      });
    }

    mountGallery("single-grid", singles);
    mountGallery("pyr-grid", pyramids);
    mountComparisonTable();
    mountTrialComparison();
  </script>
</body>
</html>